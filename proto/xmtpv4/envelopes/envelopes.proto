// Message API for XMTP V4
syntax = "proto3";

package xmtp.xmtpv4.envelopes;

import "identity/associations/association.proto";
import "identity/associations/signature.proto";
import "mls/api/v1/mls.proto";

option go_package = "github.com/xmtp/proto/v3/go/xmtpv4/envelopes";

// The last seen entry per originator. Originators that have not been seen are omitted.
// Entries MUST be sorted in ascending order, so that smaller node ID's appear first.
message VectorClock {
  map<uint32, uint64> node_id_to_sequence_id = 1;
}

// Data visible to the server that has been authenticated by the client.
message AuthenticatedData {
  uint32 target_originator = 1;
  bytes target_topic = 2;
  VectorClock last_seen = 3;
}

message ClientEnvelope {
  AuthenticatedData aad = 1;

  oneof payload {
    xmtp.mls.api.v1.GroupMessageInput group_message = 2;
    xmtp.mls.api.v1.WelcomeMessageInput welcome_message = 3;
    xmtp.mls.api.v1.UploadKeyPackageRequest upload_key_package = 4;
    xmtp.identity.associations.IdentityUpdate identity_update = 5;
  }
}

// Wraps client envelope with payer signature
message PayerEnvelope {
  bytes unsigned_client_envelope = 1; // Protobuf serialized
  xmtp.identity.associations.RecoverableEcdsaSignature payer_signature = 2;
}

// For blockchain envelopes, these fields are set by the smart contract
message UnsignedOriginatorEnvelope {
  uint32 originator_node_id = 1;
  uint64 originator_sequence_id = 2;
  int64 originator_ns = 3;
  PayerEnvelope payer_envelope = 4;
}

// An alternative to a signature for blockchain payloads
message BlockchainProof {
  bytes transaction_hash = 1;
}

// Signed originator envelope
message OriginatorEnvelope {
  bytes unsigned_originator_envelope = 1; // Protobuf serialized
  oneof proof {
    xmtp.identity.associations.RecoverableEcdsaSignature originator_signature = 2;
    BlockchainProof blockchain_proof = 3;
  }
}

enum Misbehavior {
  MISBEHAVIOR_UNSPECIFIED = 0;
  MISBEHAVIOR_UNRESPONSIVE_NODE = 1;
  MISBEHAVIOR_SLOW_NODE = 2;
  MISBEHAVIOR_FAILED_REQUEST = 3;
  MISBEHAVIOR_OUT_OF_ORDER = 4;
  MISBEHAVIOR_DUPLICATE_SEQUENCE_ID = 5;
  MISBEHAVIOR_CAUSAL_ORDERING = 6;
  MISBEHAVIOR_INVALID_PAYLOAD = 7;
  MISBEHAVIOR_BLOCKCHAIN_INCONSISTENCY = 8;
}

message LivenessFailure {
  uint32 response_time_ns = 1;
  SubscribeEnvelopesRequest subscribe = 2;
  QueryEnvelopesRequest query = 3;
  PublishPayerEnvelopesRequest publish = 4;
}

message SafetyFailure {
  repeated OriginatorEnvelope envelopes = 1;
}

message UnsignedMisbehaviorReport {
  uint64 reporter_time_ns = 1;
  uint32 misbehaving_node_id = 2;
  Misbehavior type = 3;
  LivenessFailure liveness = 4;
  SafetyFailure safety = 5;
  // Nodes must verify this field is false for client-submitted reports
  bool submitted_by_node = 6;
}

message MisbehaviorReport {
  // Server time when the report was stored. Used only for querying reports.
  // This field is not signed.
  uint64 server_time_ns = 1;
  bytes unsigned_misbehavior_report = 2;
  // Signed by the node hosting the report
  xmtp.identity.associations.RecoverableEcdsaSignature signature = 3;
}
