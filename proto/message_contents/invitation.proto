// Invitation is used by an initiator to invite participants
// into a new conversation. Invitation carries the chosen topic name
// and encryption scheme and key material to be used for message encryption.
syntax = "proto3";

package xmtp.message_contents;

import "message_contents/ciphertext.proto";
import "message_contents/public_key.proto";

option go_package = "github.com/xmtp/proto/v3/go/message_contents";
option java_package = "org.xmtp.proto.message.contents";

// Unsealed invitation V1
message InvitationV1 {
    // Supported encryption schemes
    // AES256-GCM-HKDF-SHA256
    message Aes256gcmHkdfsha256 {
        bytes key_material = 1; // randomly generated key material (32 bytes)
    }

    // The context type
    message Context {
        // Expected to be a URI (ie xmtp.org/convo1)
        string conversation_id = 1;
        // Key value map of additional metadata that would be exposed to
        // application developers and could be used for filtering
        map<string, string> metadata = 2;
    }
    // topic name chosen for this conversation.
    // It MUST be randomly generated bytes (length >= 32),
    // then base64 encoded without padding
    string topic = 1;
    
    // A context object defining metadata
    Context context = 2;

    // message encryption scheme and keys for this conversation.
    oneof encryption {
        // Specify the encryption method to process the key material properly.
        Aes256gcmHkdfsha256 aes256_gcm_hkdf_sha256 = 3;
    }
}

// Header carries information that is unencrypted, thus readable by the network
// it is however authenticated as associated data with the AEAD scheme used
// to encrypt the invitation body, thus providing tamper evidence.
// The inbox_key_bundle MUST be linked to the address of the recipient.
message SealedInvitationHeaderV2 {
    // PeerInvitationHeader MUST be used when the account address linked to the
    // send_key_bundle is different from the address linked to the
    // inbox_key_bundle
    message PeerInvitationHeader {
        SignedPublicKeyBundleV2 send_key_bundle = 1;
        SignedPublicKeyBundleV2 inbox_key_bundle = 2;
        uint64 created_ns = 3;
    }

    // When receiving this header, the send_key_bundle MUST have an
    // AccountLinkedPublicKey that is linked to the user's account
    message SelfInvitationHeader {
        SignedPublicKeyBundleV2 send_key_bundle = 1;
        SignedPublicKeyBundleV2 inbox_key_bundle = 2;
        uint64 created_ns = 3;
        // The address of the person being invited to the conversation
        string recipient_address = 4;
    }

    oneof header {
        PeerInvitationHeader peer_header = 1;
        SelfInvitationHeader self_header = 2;
    }
}

// Sealed Invitation V2
// Invitation encrypted with key material derived from the sender's and
// recipient's public key bundles using simplified X3DH where
// the sender's ephemeral key is replaced with sender's pre-key.
message SealedInvitationV2 {
    // encoded SealedInvitationHeaderV2 used as associated data for Ciphertext
    bytes header_bytes = 1; 
    // Ciphertext.payload MUST contain encrypted InvitationV1.
    Ciphertext ciphertext = 2; 
}

// Versioned Sealed Invitation
message SealedInvitation {
    oneof version {
        SealedInvitationV1 v1 = 1;
        SealedInvitationV2 v2 = 2;
    };
}


// DEPRECATION IN PROGRESS

// Sealed Invitation V1 Header
// Header carries information that is unencrypted, thus readable by the network
// it is however authenticated as associated data with the AEAD scheme used
// to encrypt the invitation body, thus providing tamper evidence.
message SealedInvitationHeaderV1 {
    SignedPublicKeyBundle sender = 1;
    SignedPublicKeyBundle recipient = 2;
    uint64 created_ns = 3;
}

// Sealed Invitation V1
// Invitation encrypted with key material derived from the sender's and
// recipient's public key bundles using simplified X3DH where
// the sender's ephemeral key is replaced with sender's pre-key.
message SealedInvitationV1 {
    // encoded SealedInvitationHeaderV1 used as associated data for Ciphertext
    bytes header_bytes = 1; 
    // Ciphertext.payload MUST contain encrypted InvitationV1.
    Ciphertext ciphertext = 2; 
}
